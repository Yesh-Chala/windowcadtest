<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #windowCADdesigner {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 70vh; /* Takes up 70% of the viewport height */
            background: white;
            z-index: 1000;
        }
    
        #windowCADdesigner > div {
            position: relative;
            height: 100%;
            width: 100%;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.1);
        }
    
        #windowCADiFrame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
            margin: 0;
            padding: 0;
        }
    
        #windowCADcloseButton {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1001;
        }
    
        #windowCADcloseButton path {
            fill: #ddd;
            stroke: #000;
            stroke-width: 3px;
            cursor: pointer;
        }
    
        #windowCADcloseButton path:hover {
            fill: #bbb;
        }
    
        #windowCADcloseButton path:active {
            fill: #333;
            stroke: #bbb;
        }
    </style>
</head>
<body>
    <button id="windowCADdesignButton">Save Quote</button>
    <div id="windowCADdesigner">
        <div>
                       <iframe id="windowCADiFrame" src="https://www.windowsoftware.co.uk/windowcad7/?interface=retail&username=moliwindows"></iframe>
            <svg id="windowCADcloseButton" width="40" height="40">
                <path d="M38.5,20 A18.5,18.5 0 1 1 38.5,19.99 Z M29,11 11,29 M11,11 29,29"></path>
            </svg>
        </div>
    </div>
    <script>
        const windowCADdesignButton = document.getElementById(
            "windowCADdesignButton"
        );
        const windowCADdesigner = document.getElementById("windowCADdesigner");
        const windowCADcloseButton = document.getElementById(
            "windowCADcloseButton"
        );
        const windowCADiFrame = document.getElementById("windowCADiFrame");
    
        windowCADdesignButton.addEventListener("click", () => {
            windowCADdesigner.style.display = "block";
        });
        
        windowCADcloseButton.addEventListener("click", () => {
            windowCADdesigner.style.display = "";
        });


        // Listen for messages from the WindowCAD iframe
        window.addEventListener("message", e => {
            if (e && e.data && e.data.isWindowCAD && e.data.appType === "Retail") {
                console.log('WindowCAD data received:', e.data);
                
                if (e.data.pdfBlob) {
                    console.log('PDF Blob received:', e.data.pdfBlob);
                    // Create a download link for the PDF
                    const pdfUrl = URL.createObjectURL(e.data.pdfBlob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = pdfUrl;
                    downloadLink.download = 'window-design.pdf';
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    URL.revokeObjectURL(pdfUrl);
                    console.log('PDF download triggered');
                }


                if (e.data.projectJson) {
                    console.log('Project JSON data:', e.data.projectJson);


                   // Store raw
                    localStorage.setItem('windowCADProject', JSON.stringify(e.data.projectJson));
                    console.log('Project data saved to localStorage');


                   // Extract and log cleaned version
                   const cleanedData = extractImportantDetails(e.data.projectJson);
                   console.log('Parsed Important Quote Data:', cleanedData);


                   // Optional: Save that too
                   localStorage.setItem('parsedQuote', JSON.stringify(cleanedData));
               }




                if (e.data.userAgent) {
                    console.log('User Agent:', e.data.userAgent);
                }
            }
        });


        // Function to send commands to WindowCAD
        function sendToWindowCAD(command, data) {
            windowCADiFrame.contentWindow.postMessage({
                type: command,
                data: data
            }, "https://www.windowsoftware.co.uk");
       }
               function extractImportantDetails(projectJson) {
            const quote = {
                project: {
                    version: projectJson?.version || 'Unknown',
                    createdDate: projectJson?.createdDate || null,
                    status: projectJson?.statusName || 'Unknown',
                    includeInstallation: projectJson?.includeInstallation || false,
                    taxPercent: projectJson?.taxPercent || 0
                },
                items: [],
                summary: {
                    totalItems: 0,
                    totalQuantity: 0,
                    subtotal: 0,
                    tax: 0,
                    grandTotal: 0
                }
            };

            // Process each bay (main quote items)
            if (projectJson?.bays && Array.isArray(projectJson.bays)) {
                projectJson.bays.forEach((bay, bayIndex) => {
                    // Extract frame colors from bay level
                    const frameColours = bay.frameColours || [];
                    const externalFinish = frameColours.length > 0 ? frameColours[0] : 'Unknown';
                    const internalFinish = frameColours.length > 1 ? frameColours[1] : externalFinish;

                    const item = {
                        itemNumber: bayIndex + 1,
                        quantity: bay.quantity || 1,
                        unitPrice: bay.price || 0,
                        totalPrice: (bay.quantity || 1) * (bay.price || 0),
                        
                        designDetails: {
                            frameType: bay.infoProperties?.[0]?.value || 'Unknown Frame Type',
                            configuration: 'Unknown',
                            dimensions: 'Unknown'
                        },
                        
                        appearance: {
                            externalFinish: externalFinish,
                            internalFinish: internalFinish
                        },
                        
                        glazing: {
                            type: 'Unknown',
                            specs: 'Unknown'
                        },
                        
                        hardware: {
                            cylinderType: 'Unknown',
                            cylinderMaterial: 'Unknown',
                            handleType: 'Unknown',
                            handleFinish: 'Unknown'
                        }
                    };

                    // Process frame collections to get detailed specs
                    if (bay.frameCollections && Array.isArray(bay.frameCollections)) {
                        bay.frameCollections.forEach(collection => {
                            // Update dimensions from collection
                            if (collection.width && collection.height) {
                                item.designDetails.dimensions = `${collection.width} x ${collection.height}`;
                            }

                            // Process frames for configuration and glazing details
                            if (collection.frames && Array.isArray(collection.frames)) {
                                collection.frames.forEach(frame => {
                                    // Update configuration
                                    if (frame.frameStyle) {
                                        item.designDetails.configuration = frame.frameStyle;
                                    }

                                    // Extract glazing and hardware from apertures
                                    if (frame.apertures && Array.isArray(frame.apertures)) {
                                        frame.apertures.forEach(aperture => {
                                            // Process sash frames for glazing and hardware
                                            if (aperture.sashFrames && Array.isArray(aperture.sashFrames)) {
                                                aperture.sashFrames.forEach(sash => {
                                                    // Extract glazing information
                                                    if (sash.apertures && sash.apertures[0]) {
                                                        const glazingAperture = sash.apertures[0];
                                                        if (glazingAperture.product) {
                                                            item.glazing.type = glazingAperture.product;
                                                        }
                                                        if (glazingAperture.glazing?.spacerBar) {
                                                            item.glazing.specs = glazingAperture.glazing.spacerBar;
                                                        }
                                                    }

                                                    // Extract hardware information
                                                    if (sash.hardware && Array.isArray(sash.hardware)) {
                                                        sash.hardware.forEach(hw => {
                                                            if (hw.type === 'Cylinder') {
                                                                item.hardware.cylinderType = hw.style || 'Standard';
                                                                item.hardware.cylinderMaterial = hw.colour || 'Unknown';
                                                            } else if (hw.type === 'Door_handle') {
                                                                item.hardware.handleType = hw.style || 'Unknown';
                                                                item.hardware.handleFinish = hw.colour || 'Unknown';
                                                            }
                                                        });
                                                    }
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }

                    // Add complete pricing calculation data (includes product + glazing)
                    item.pricingData = extractCompletePricingDetails(bay);
                    
                    quote.items.push(item);
                });
            }

            // Calculate summary
            quote.summary.totalItems = quote.items.length;
            quote.summary.totalQuantity = quote.items.reduce((sum, item) => sum + item.quantity, 0);
            quote.summary.subtotal = quote.items.reduce((sum, item) => sum + item.totalPrice, 0);
            quote.summary.tax = quote.summary.subtotal * (quote.project.taxPercent / 100);
            quote.summary.grandTotal = quote.summary.subtotal + quote.summary.tax;

            return quote;
        }

        function parseProductName(fullName) {
            const parsed = {
                fullName: fullName,
                series: null,
                style: null,
                type: null,
                swing: null
            };

            // Split by hyphen to separate main part and swing
            const parts = fullName.split(' - ');
            const mainPart = parts[0].trim();
            const swingPart = parts.length > 1 ? parts[1].trim() : null;

            // Split main part into tokens
            const tokens = mainPart.split(/\s+/);
            
            let currentIndex = 0;
            
            // Extract series (first number token)
            if (currentIndex < tokens.length) {
                const firstToken = tokens[currentIndex];
                const seriesMatch = firstToken.match(/^\d+/);
                if (seriesMatch) {
                    parsed.series = parseInt(seriesMatch[0]);
                    currentIndex++;
                }
            }

            // Extract style (Classic or Contemporary)
            if (currentIndex < tokens.length) {
                const styleToken = tokens[currentIndex].toLowerCase();
                if (styleToken === 'classic' || styleToken === 'contemporary') {
                    parsed.style = tokens[currentIndex]; // Keep original case
                    currentIndex++;
                }
            }

            // Extract type (remaining words)
            if (currentIndex < tokens.length) {
                const typeTokens = tokens.slice(currentIndex);
                const rawType = typeTokens.join(' ');
                parsed.type = normalizeType(rawType);
            }

            // Extract swing (after hyphen)
            if (swingPart) {
                const swingLower = swingPart.toLowerCase();
                if (swingLower.includes('inswing')) {
                    parsed.swing = 'Inswing';
                } else if (swingLower.includes('outswing')) {
                    parsed.swing = 'Outswing';
                } else {
                    parsed.swing = swingPart; // Keep original if not standard
                }
            }

            // Check if swing should be null for certain types
            if (parsed.type && shouldIgnoreSwing(parsed.type)) {
                parsed.swing = null;
            }

            return parsed;
        }

        function normalizeType(rawType) {
            const type = rawType.toLowerCase().trim();
            
            // Canonical type mappings
            const typeMap = {
                'fixed': 'Fixed',
                'tilt & turn': 'Tilt & Turn',
                'tilt and turn': 'Tilt & Turn',
                'casement - inswing': 'Inswing Casement',
                'inswing casement': 'Inswing Casement',
                'casement inswing': 'Inswing Casement',
                'awning': 'Outward (Outswing Casement / Awning)',
                'outswing casement': 'Outward (Outswing Casement / Awning)',
                'outward': 'Outward (Outswing Casement / Awning)',
                'single hinge door': 'Single Hinge Door',
                'french door': 'French Door',
                'sliding door': 'Sliding Door',
                'sliding window': 'Sliding Window',
                'tilt & slide window': 'Sliding Window',
                'bifold door': 'Bifold Door',
                'bi-fold': 'Bifold Door',
                'standard bi-fold': 'Bifold Door'
            };

            // Check for exact matches first
            if (typeMap[type]) {
                return typeMap[type];
            }

            // Check for partial matches
            for (const [key, value] of Object.entries(typeMap)) {
                if (type.includes(key) || key.includes(type)) {
                    return value;
                }
            }

            // If no match found, return capitalized version
            return rawType.split(' ').map(word => 
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }

        function shouldIgnoreSwing(type) {
            const noSwingTypes = [
                'Fixed',
                'Tilt & Turn', 
                'Sliding Door',
                'Sliding Window',
                'Bifold Door'
            ];
            return noSwingTypes.includes(type);
        }

        // Glazing price lookup table (price per square foot)
        const glazingPrices = {
            'Dual Standard Low E': 15.97,
            'Dual Double Low E': 20.03,
            'Dual Triple Low E': 24.08,
            'Triple Standard Low E': 18.97,
            'Triple Double Low E': 20.02,
            'Triple Triple Low E': 24.08,
            'Triple XO E': 26.18
        };

        // Product pricing configuration (price per square foot)
        const PRODUCT_PRICING = {
            '85-Contemporary': {
                'Fixed': 32.24,
                'Outward (Outswing Casement / Awning)': 67.39,
                'Inswing Casement': 67.39,
                'Tilt & Turn': 74.63,
                'Single Hinge Door': 104.20,
                'French Door': 150.19
            },
            '76-Classic': {
                'Fixed': 23.57,
                'Outward (Outswing Casement / Awning)': 49.74,
                'Inswing Casement': 49.74,
                'Tilt & Turn': 55.53,
                'Single Hinge Door': 70.64,
                'French Door': 73.94
            },
            '108-Contemporary': {
                'Tilt & Slide w/screen': 39.53
            },
            '148-Contemporary': {
                'Sliding Window w/screen': 39.53
            },
            '152-Classic': {
                'Lift & Slide': 74.98
            },
            '182-Classic': {
                'Lift & Slide Hardware': 2554.00
            },
            '236-Classic': {
                'Classic Lift & Slide (3 Tracks)': 89.98,
                'Classic Lift & Slide (3 Tracks) Hardware': 2254.00
            },
            '120-Contemporary': {
                'Traditional Sliding Door (2 Tracks)': 37.71,
                'Traditional Sliding Door (2 Tracks) Hardware': 1836.97,
                'Lift & Slide (2 Tracks)': 41.90,
                'Lift & Slide (2 Tracks) Hardware': 2254.00
            },
            '185-Contemporary': {
                'Traditional Sliding Door (3 Tracks)': 41.83,
                'Traditional Sliding Door (3 Tracks) Hardware': 1836.97,
                'Lift & Slide (3 Tracks)': 48.70,
                'Lift & Slide (3 Tracks) Hardware': 2043.30
            },
            '251-Contemporary': {
                'Traditional Sliding Door (4 Tracks)': 52.60,
                'Traditional Sliding Door (4 Tracks) Hardware': 2043.30
            }
        };

        // Special pricing rules
        const SPECIAL_PRICING = {
            'Screen': {
                // Screen for series 79 & 85 - Fiberglass pricing with minimum 10.76 SQFT
                'applicableSeries': [79, 85],
                'types': {
                    'Fiberglass': {
                        pricePerSqFt: 9.47,
                        minimumSqFt: 10.76,
                        note: 'If size less than 10.76 SQFT, equal to 10.76 SQFT'
                    }
                }
            }
        };

        // Product pricing matching engine
        function findProductPrice(productName, dimensions = null) {
            console.log('ðŸ” Finding price for product:', productName);
            
            // Parse the product name using existing logic
            const parsed = parseProductName(productName);
            console.log('ðŸ“‹ Parsed product:', parsed);
            
            // Create series-style lookup key
            const seriesStyleKey = `${parsed.series}-${parsed.style}`;
            
            // Try direct lookup first
            const directPrice = directProductLookup(seriesStyleKey, parsed.type);
            if (directPrice) {
                return calculateFinalProductPrice(directPrice, dimensions, parsed, 'Direct Match');
            }
            
            // Try fuzzy matching
            const fuzzyPrice = fuzzyProductLookup(seriesStyleKey, parsed.type);
            if (fuzzyPrice) {
                return calculateFinalProductPrice(fuzzyPrice.price, dimensions, parsed, fuzzyPrice.matchType);
            }
            
            // Check special pricing (screens, etc.)
            const specialPrice = checkSpecialPricing(parsed, dimensions);
            if (specialPrice) {
                return specialPrice;
            }
            
            // No match found
            console.log('âŒ No pricing found for:', productName);
            return {
                found: false,
                error: 'No pricing data available',
                productName: productName,
                parsed: parsed
            };
        }

        function directProductLookup(seriesStyleKey, productType) {
            const seriesPricing = PRODUCT_PRICING[seriesStyleKey];
            if (seriesPricing && seriesPricing[productType] !== undefined) {
                console.log('âœ… Direct match found:', `${seriesStyleKey} -> ${productType} = $${seriesPricing[productType]}`);
                return seriesPricing[productType];
            }
            return null;
        }

        function fuzzyProductLookup(seriesStyleKey, productType) {
            const seriesPricing = PRODUCT_PRICING[seriesStyleKey];
            if (!seriesPricing) {
                console.log('âŒ Series not found:', seriesStyleKey);
                return null;
            }
            
            // Try partial matching on product types
            const availableTypes = Object.keys(seriesPricing);
            console.log('ðŸ”„ Trying fuzzy matching against:', availableTypes);
            
            // Look for partial matches
            for (const availableType of availableTypes) {
                // Check if product type contains or is contained in available type
                const normalizedProduct = productType.toLowerCase();
                const normalizedAvailable = availableType.toLowerCase();
                
                // Contains match
                if (normalizedProduct.includes(normalizedAvailable) || normalizedAvailable.includes(normalizedProduct)) {
                    console.log('ðŸŽ¯ Fuzzy match found:', `${productType} â‰ˆ ${availableType}`);
                    return {
                        price: seriesPricing[availableType],
                        matchType: `Fuzzy Match (${availableType})`
                    };
                }
                
                // Word-based matching for complex types
                const productWords = normalizedProduct.split(/\s+/);
                const availableWords = normalizedAvailable.split(/\s+/);
                const commonWords = productWords.filter(word => availableWords.includes(word));
                
                if (commonWords.length >= 2) { // At least 2 words in common
                    console.log('ðŸŽ¯ Word-based fuzzy match:', `${productType} â‰ˆ ${availableType} (common: ${commonWords.join(', ')})`);
                    return {
                        price: seriesPricing[availableType],
                        matchType: `Word Match (${availableType})`
                    };
                }
            }
            
            return null;
        }

        function checkSpecialPricing(parsed, dimensions) {
            // Check for screen pricing (series 79 & 85)
            if (parsed.series && SPECIAL_PRICING.Screen.applicableSeries.includes(parsed.series)) {
                if (parsed.type && parsed.type.toLowerCase().includes('fiberglass')) {
                    const screenPricing = SPECIAL_PRICING.Screen.types.Fiberglass;
                    const squareFeet = dimensions?.squareFeet || 0;
                    const effectiveSqFt = Math.max(squareFeet, screenPricing.minimumSqFt);
                    
                    console.log('ðŸŽ¯ Special screen pricing applied:', {
                        series: parsed.series,
                        actualSqFt: squareFeet,
                        minimumSqFt: screenPricing.minimumSqFt,
                        effectiveSqFt: effectiveSqFt,
                        pricePerSqFt: screenPricing.pricePerSqFt
                    });
                    
                    return {
                        found: true,
                        matchType: 'Special Screen Pricing',
                        pricePerSqFt: screenPricing.pricePerSqFt,
                        effectiveSquareFeet: effectiveSqFt,
                        productPrice: (screenPricing.pricePerSqFt * effectiveSqFt).toFixed(2),
                        note: screenPricing.note,
                        productName: parsed.fullName,
                        parsed: parsed
                    };
                }
            }
            return null;
        }

        function calculateFinalProductPrice(pricePerSqFt, dimensions, parsed, matchType) {
            if (!dimensions || !dimensions.squareFeet) {
                console.log('âš ï¸ No dimensions available for price calculation');
                return {
                    found: true,
                    matchType: matchType,
                    pricePerSqFt: pricePerSqFt,
                    productPrice: null,
                    error: 'Dimensions required for final price calculation',
                    productName: parsed.fullName,
                    parsed: parsed
                };
            }
            
            const squareFeet = dimensions.squareFeet;
            const productPrice = (pricePerSqFt * squareFeet).toFixed(2);
            
            console.log('ðŸ’° Final product price calculated:', {
                matchType: matchType,
                pricePerSqFt: `$${pricePerSqFt}`,
                squareFeet: squareFeet.toFixed(2),
                productPrice: `$${productPrice}`
            });
            
            return {
                found: true,
                matchType: matchType,
                pricePerSqFt: pricePerSqFt,
                squareFeet: squareFeet,
                productPrice: productPrice,
                productName: parsed.fullName,
                parsed: parsed
            };
        }

        // Enhanced pricing extraction that includes product pricing
        function extractCompletePricingDetails(bay) {
            // Get existing pricing data
            const pricingData = extractPricingDetails(bay);
            
            // Add product pricing
            const productPricing = findProductPrice(
                pricingData.productName.fullName, 
                pricingData.dimensions
            );
            
            // Combine all pricing information
            const completePricing = {
                ...pricingData,
                productPricing: productPricing,
                totalEstimate: null
            };
            
            // Calculate total estimate if both glazing and product pricing are available
            if (pricingData.glazing.totalCost && productPricing.found && productPricing.productPrice) {
                const glazingCost = parseFloat(pricingData.glazing.totalCost);
                const productCost = parseFloat(productPricing.productPrice);
                completePricing.totalEstimate = (glazingCost + productCost).toFixed(2);
                
                console.log('ðŸ’° Complete Pricing Summary:');
                console.log(`   ðŸªŸ Product Cost: $${productPricing.productPrice} (${productPricing.matchType})`);
                console.log(`   ðŸ” Glazing Cost: $${pricingData.glazing.totalCost}`);
                console.log(`   ðŸ“Š Total Estimate: $${completePricing.totalEstimate}`);
            }
            
            return completePricing;
        }

        function constructGlazingText(paneCount, lowECount) {
            let paneText = '';
            let lowEText = '';
            
            // Map pane count to text
            switch(paneCount) {
                case 2: paneText = 'Dual'; break;
                case 3: paneText = 'Triple'; break;
                default: paneText = 'Unknown';
            }
            
            // Map Low-E count to text
            switch(lowECount) {
                case 1: lowEText = 'Standard'; break;
                case 2: lowEText = 'Double'; break;
                case 3: lowEText = 'Triple'; break;
                default: lowEText = 'Unknown';
            }
            
            if (paneText === 'Unknown' || lowEText === 'Unknown') {
                return 'Unknown Glazing Configuration';
            }
            
            return `${paneText} ${lowEText} Low E`;
        }

        function calculateGlazingCost(glazingText, squareFeet) {
            const pricePerSqFt = glazingPrices[glazingText];
            if (!pricePerSqFt || !squareFeet) {
                return {
                    pricePerSqFt: null,
                    totalCost: null,
                    error: 'Missing price data or dimensions'
                };
            }
            
            return {
                pricePerSqFt: pricePerSqFt,
                totalCost: (pricePerSqFt * squareFeet).toFixed(2),
                error: null
            };
        }

        function extractPricingDetails(bay) {
            const pricingData = {
                dimensions: {
                    width: null,
                    height: null,
                    widthMM: null,
                    heightMM: null,
                    widthInches: null,
                    heightInches: null,
                    squareFeet: null,
                    squareInches: null
                },
                glazing: {
                    paneCount: null,
                    paneType: 'Unknown',
                    lowEType: 'Unknown',
                    lowECount: 0,
                    fullGlazingSpec: 'Unknown',
                    constructedText: 'Unknown',
                    pricePerSqFt: null,
                    totalCost: null
                },
                productName: {
                    fullName: 'Unknown',
                    series: null,
                    style: null,
                    type: null,
                    swing: null
                }
            };

            // Parse product name
            const productName = bay.infoProperties?.[0]?.value || 'Unknown';
            pricingData.productName = parseProductName(productName);

            // Extract dimensions from frame collections
            if (bay.frameCollections && Array.isArray(bay.frameCollections)) {
                bay.frameCollections.forEach((collection) => {
                    if (collection.width) {
                        pricingData.dimensions.width = collection.width;
                        pricingData.dimensions.widthMM = collection.width; // Already in MM
                    }
                    if (collection.height) {
                        pricingData.dimensions.height = collection.height;
                        pricingData.dimensions.heightMM = collection.height; // Already in MM
                    }

                    // Convert to inches and calculate square footage
                    if (pricingData.dimensions.widthMM && pricingData.dimensions.heightMM) {
                        const mmToInches = 0.0393701; // 1 mm = 0.0393701 inches
                        
                        pricingData.dimensions.widthInches = pricingData.dimensions.widthMM * mmToInches;
                        pricingData.dimensions.heightInches = pricingData.dimensions.heightMM * mmToInches;
                        
                        // Calculate area
                        pricingData.dimensions.squareInches = pricingData.dimensions.widthInches * pricingData.dimensions.heightInches;
                        pricingData.dimensions.squareFeet = pricingData.dimensions.squareInches / 144; // 144 square inches = 1 square foot
                    }

                    // Extract glazing details from frames
                    if (collection.frames && Array.isArray(collection.frames)) {
                        collection.frames.forEach((frame) => {
                            // Process apertures for glazing
                            if (frame.apertures && Array.isArray(frame.apertures)) {
                                frame.apertures.forEach((aperture) => {
                                    // Process sash frames for glazing specs
                                    if (aperture.sashFrames && Array.isArray(aperture.sashFrames)) {
                                        aperture.sashFrames.forEach((sash) => {
                                            if (sash.apertures && sash.apertures[0]) {
                                                const glazingProduct = sash.apertures[0].product;
                                                
                                                pricingData.glazing.fullGlazingSpec = glazingProduct;
                                                
                                                // Parse pane information from product string
                                                if (glazingProduct) {
                                                    // Extract pane count (Double-Pane, Triple-Pane, etc.)
                                                    if (glazingProduct.toLowerCase().includes('double-pane')) {
                                                        pricingData.glazing.paneCount = 2;
                                                        pricingData.glazing.paneType = 'Double-Pane';
                                                    } else if (glazingProduct.toLowerCase().includes('triple-pane')) {
                                                        pricingData.glazing.paneCount = 3;
                                                        pricingData.glazing.paneType = 'Triple-Pane';
                                                    } else if (glazingProduct.toLowerCase().includes('single-pane')) {
                                                        pricingData.glazing.paneCount = 1;
                                                        pricingData.glazing.paneType = 'Single-Pane';
                                                    }
                                                    
                                                    // Extract Low-E information
                                                    const lowEMatches = glazingProduct.match(/(\d+)-?Low-?E/gi);
                                                    if (lowEMatches) {
                                                        const lowEMatch = lowEMatches[0];
                                                        const lowENumber = lowEMatch.match(/(\d+)/);
                                                        if (lowENumber) {
                                                            pricingData.glazing.lowECount = parseInt(lowENumber[1]);
                                                            pricingData.glazing.lowEType = lowEMatch;
                                                        }
                                                    } else if (glazingProduct.toLowerCase().includes('low-e')) {
                                                        pricingData.glazing.lowECount = 1;
                                                        pricingData.glazing.lowEType = 'Low-E';
                                                    }
                                                }
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                });
            }

            // Construct glazing text after all glazing data is extracted
            if (pricingData.glazing.paneCount && pricingData.glazing.lowECount > 0) {
                pricingData.glazing.constructedText = constructGlazingText(
                    pricingData.glazing.paneCount, 
                    pricingData.glazing.lowECount
                );
                
                // Calculate glazing cost
                const costCalculation = calculateGlazingCost(
                    pricingData.glazing.constructedText,
                    pricingData.dimensions.squareFeet
                );
                
                pricingData.glazing.pricePerSqFt = costCalculation.pricePerSqFt;
                pricingData.glazing.totalCost = costCalculation.totalCost;
                
                console.log('ðŸ·ï¸ Glazing Text Constructed:', {
                    'Pane Count': pricingData.glazing.paneCount,
                    'Low-E Count': pricingData.glazing.lowECount, 
                    'Constructed Text': pricingData.glazing.constructedText
                });
                
                if (costCalculation.error) {
                    console.log('âŒ Glazing Cost Calculation Error:', costCalculation.error);
                } else {
                    console.log('ðŸ’² Glazing Cost Calculation:', {
                        'Square Feet': pricingData.dimensions.squareFeet?.toFixed(2),
                        'Price per Sq Ft': `$${costCalculation.pricePerSqFt}`,
                        'Total Glazing Cost': `$${costCalculation.totalCost}`
                    });
                }
            }

            // Log essential pricing data
            console.log('ðŸ’° Pricing Data Summary for:', pricingData.productName.fullName);
            console.log('   ðŸ“ Dimensions:', `${pricingData.dimensions.widthMM} x ${pricingData.dimensions.heightMM} mm (${pricingData.dimensions.squareFeet?.toFixed(2)} sq ft)`);
            console.log('   ðŸªŸ Glazing:', pricingData.glazing.constructedText || 'Unknown');
            if (pricingData.glazing.totalCost) {
                console.log('   ðŸ’² Glazing Cost:', `$${pricingData.glazing.totalCost} (${pricingData.dimensions.squareFeet?.toFixed(2)} sq ft Ã— $${pricingData.glazing.pricePerSqFt}/sq ft)`);
            }

            return pricingData;
        }




        // Test function to demonstrate pricing system
        function testProductPricing() {
            console.log('ðŸ§ª Testing Product Pricing System:');
            console.log('='.repeat(50));
            
            const testProducts = [
                { name: '85 Contemporary Fixed - Inswing', dimensions: { squareFeet: 10.5 } },
                { name: '76 Classic Tilt & Turn', dimensions: { squareFeet: 8.2 } },
                { name: '120 Contemporary Traditional Sliding Door (2 Tracks)', dimensions: { squareFeet: 15.3 } },
                { name: '185 Contemporary Lift & Slide (3 Tracks) Hardware', dimensions: { squareFeet: 20.0 } },
                { name: '79 Contemporary Fiberglass Screen', dimensions: { squareFeet: 5.5 } } // Should use minimum 10.76
            ];
            
            testProducts.forEach((test, index) => {
                console.log(`\nðŸ” Test ${index + 1}: "${test.name}"`);
                const result = findProductPrice(test.name, test.dimensions);
                console.log('Result:', result);
            });
            
            console.log('\n' + '='.repeat(50));
            console.log('âœ… Product Pricing Test Complete!');
        }
        
        // Uncomment the line below to run tests on page load
        // testProductPricing();

        // Example of how to trigger a save quote action
        windowCADdesignButton.addEventListener("click", () => {
            if (windowCADdesigner.style.display === "block") {
                // If the designer is already open, trigger save quote
                sendToWindowCAD('saveQuote', {});
            } else {
                // If the designer is closed, open it
                windowCADdesigner.style.display = "block";
            }
        });
    </script>
</body>
</html>
